import { loadConfig } from "c12";
import chokidar from "chokidar";
import debounce from "debounce";
import esbuild, { type OnLoadArgs } from "esbuild";
import fs from "fs-extra";
import path from "node:path";
import glob from "tiny-glob";
import { type ScriptConfig } from "./config.js";
import { installScript } from "./util/bettergi.js";
import { syncManifestConfig, syncSettingsConfig } from "./util/meta.js";
import { terminate } from "./util/process.js";
import { sanitizeVariableName, sha256 } from "./util/string.js";

(async () => {
  const loadConfiguration = async (): Promise<{
    config: ScriptConfig;
    filepath: string;
  }> => {
    const { config, configFile } = await loadConfig({ name: "bettergi" });
    if (!configFile) return terminate("No bettergi.config.(js,ts,cjs,mjs) files found");

    return { config: config, filepath: configFile };
  };

  const { config, filepath } = await loadConfiguration();
  const main = [config.main || "main.ts"];
  const assetsDir = config.assetsDir || "assets";
  const outDir = path.resolve(config.outDir || "dist");
  const additionalFiles = [
    ...(Array.isArray(config.additionalFiles)
      ? config.additionalFiles
      : config.additionalFiles
        ? [config.additionalFiles]
        : ["README.md", "LICENSE"])
  ];
  const loaders = config.loaders || {};
  const minify = config.minify ?? false;
  const banner =
    config.banner === false
      ? ""
      : typeof config.banner === "string"
        ? config.banner
        : `/**
 * Better Genshin Impact JavaScript
 * Bundled with BetterGI CLI (https://www.npmjs.com/package/@bettergi/cli)
 * 
 * This file is automatically generated and should not be edited.
 */`;

  // Sync files
  const sync = debounce(
    async () => {
      try {
        // Reload config
        Object.assign(config, (await loadConfiguration()).config);

        // Write into manifest.json
        const manifest = await syncManifestConfig(outDir, config);

        // Write into settings.json
        await syncSettingsConfig(outDir, config);

        // Copy asset files
        if (fs.existsSync(assetsDir)) {
          fs.copySync(assetsDir, path.join(outDir, assetsDir));
        }

        // Copy additional files
        const copyTasks = await Promise.all(
          additionalFiles.map(async item => {
            if (typeof item === "string") {
              const paths = await glob(item, { cwd: path.resolve("."), absolute: true });
              return paths.map(p => ({
                from: p,
                to: path.resolve(outDir, path.basename(p))
              }));
            }
            if (typeof item === "object") {
              return [
                {
                  from: path.resolve(item.from),
                  to: item.to
                    ? path.resolve(outDir, item.to)
                    : path.resolve(outDir, path.basename(item.from))
                }
              ];
            }
            return [];
          })
        );
        await Promise.all(
          copyTasks.flat().map(p => fs.existsSync(p.from) && fs.copy(p.from, p.to))
        );

        // Install script if enabled
        if (config.bettergi?.enable ?? true) {
          await installScript(outDir, config, manifest);
        }
      } catch (err) {
        console.error(err);
      }
    },
    500,
    { immediate: true }
  );

  // Configure build options
  const context = await esbuild.context({
    outdir: outDir,
    entryPoints: main,
    format: "esm",
    target: "es2022",
    bundle: true,
    minify,
    legalComments: minify ? "none" : "inline",
    charset: "utf8",
    banner: { js: banner },
    plugins: [
      {
        name: "image-loader",
        setup: build => {
          const copyFile = (args: OnLoadArgs) => {
            const baseDir = loaders.image?.baseDir || "assets";

            // Create hash-based filename to avoid name conflicts
            const { name, ext } = path.parse(args.path);
            const file = `${name}-${sha256(args.path)}${ext}`;

            // Copy image to output directory
            const dest = path.join(outDir, baseDir, file);
            fs.copySync(args.path, dest);
            return `${baseDir}/${file}`;
          };
          build.onLoad({ filter: /\.(png|jpg|jpeg|bmp|tiff|webp)$/ }, args => {
            const { width, height, interpolation = 1 } = args.with;
            const file = copyFile(args);
            const variableName = sanitizeVariableName(args.path);

            // Handle ?path suffix to return file path
            if (args.suffix.includes("path")) {
              const pathVarName = `path_${variableName}`;
              return {
                contents: `const ${pathVarName} = "${file}";export { ${pathVarName} as default };`,
                loader: "js"
              };
            }

            // Return resized image or original image based on parameters
            const resize = Number(width) > 0 && Number(height) > 0;

            if (args.suffix.includes("lazy")) {
              const funcVarName = `readImageMatSync_${variableName}`;
              return resize
                ? {
                    contents: `export default function ${funcVarName}() { return file.readImageMatWithResizeSync("${file}", ${width}, ${height}, ${interpolation}); }`,
                    loader: "js"
                  }
                : {
                    contents: `export default function ${funcVarName}() { return file.readImageMatSync("${file}"); }`,
                    loader: "js"
                  };
            } else {
              const matVarName = `mat_${variableName}`;
              return resize
                ? {
                    contents: `const ${matVarName} = /* @__PURE__ */ file.readImageMatWithResizeSync("${file}", ${width}, ${height}, ${interpolation});export { ${matVarName} as default };`,
                    loader: "js"
                  }
                : {
                    contents: `const ${matVarName} = /* @__PURE__ */ file.readImageMatSync("${file}");export { ${matVarName} as default };`,
                    loader: "js"
                  };
            }
          });
        }
      },
      {
        name: "rebuild",
        setup: build => {
          build.onEnd(sync); // Sync files after build
        }
      }
    ]
  });

  // Enable watch mode if --watch argument is passed
  if (process.argv.includes("--watch")) {
    // Watch code
    await context.watch();
    // Watch files
    const watchPaths = [filepath, assetsDir, "package.json"] as string[];
    chokidar.watch(watchPaths).on("all", async (_, path, state) => {
      if (state?.isFile()) {
        console.debug(`[File Watcher]: ${path}`);
        await sync();
      }
    });
    console.log("Watching for changes...");
  } else {
    fs.removeSync(outDir); // Remove old dist folder
    await context.rebuild();
    await sync();
    await context.dispose();
    console.log("Build completed.");
  }
})();
